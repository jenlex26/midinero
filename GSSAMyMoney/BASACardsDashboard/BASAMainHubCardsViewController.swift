//
//  BASAMainHubCardsViewController.swift
//  GSSAFront
//
//  Created Andoni Suarez on 15/06/21.
//  Copyright © 2021 ___ORGANIZATIONNAME___. All rights reserved.
//
//  Template generated by Juanpe Catalán @JuanpeCMiOS
//

import UIKit
import GSSAVisualComponents
import GSSAVisualTemplates
import GSSASessionInfo
import GSSAFunctionalUtilities
import GSSAInterceptor

class BASAMainHubCardsViewController: UIViewController, BASAMainHubCardsViewProtocol, GSVCBottomAlertHandler {
    
    var bottomAlert: GSVCBottomAlert?
    var presenter: BASAMainHubCardsPresenterProtocol?
    var viewMode = 0
    
    @IBOutlet weak var BasaMainHubTableView:UITableView!
    @IBOutlet weak var headerImage: UIImageView!
    
    var cellsArray: Array<[UITableViewCell:CGFloat]> = []
    
    var accountBalance: BalanceResponse?
    var debitCardMovements: DebitCardTransaction?
    var debitCardMovementsV2: DebitCardTransactionV2?
    var lendsData: LendsResponse?
    var creditCardInfo: CreditCardInfoResponse?
    var creditCardData: CreditCardResponse?
    var creditCardBalance: CreditCardBalanceResponse?
    var creditCardMovements: CreditCardMovementsResponse?
    var accountNumber: [String:String]?
    let refreshControl = GSFMoneyRockaletaControl()
    var headerSize: CGFloat = 300.0 //380.0 Valor para cuando el usuario tiene crédito o prestamos, en caso contrario el predeterminado debería ser 300.0
    
    
    override func viewDidLoad() {
        super.viewDidLoad()
        activityTime.shared.time = TimeInterval.init(300.0)
        inicializeView()
        NotificationCenter.default.addObserver(self, selector: #selector(updateHeaderSize(sender:)), name: Notification.Name("creditCardAvailable"), object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(updateHeaderSize(sender:)), name: Notification.Name("onlyLendsAvaliable"), object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(reloadView), name: NSNotification.Name(rawValue: "externalFlowFinished"), object: nil)
        setUpRefreshControl()
        activityTime.shared.startTime = Date()
        checkTime()
        self.BasaMainHubTableView.isHidden = true
        createTag(eventName: .pageView, section: "mi_dinero", flow: "dashboard", screenName: "movimientos", origin: "debito")
    }
    
    override func viewDidAppear(_ animated: Bool) {
        loadDebitBalance()
    }
    
    override func viewWillAppear(_ animated: Bool) {
        self.navigationController?.setNavigationBarHidden(true, animated: false)
    }
    
    @objc func reloadView(){
        loadDebitBalance()
    }
    
    func checkTime(){
        DispatchQueue.main.asyncAfter(deadline: .now() + 5, execute: { [self] in
            if ((activityTime.shared.startTime ?? Date()) + (activityTime.shared.time ?? TimeInterval.init(300.0))) < Date(){
                GSINAdminNavigator.shared.releaseFlows()
            }else{
                self.checkTime()
            }
        })
    }
    
    func inicializeView(){
        setUpRefreshControl()
        ConfigureCollectionView()
        self.BasaMainHubTableView.alwaysBounceVertical = false
        NotificationCenter.default.addObserver(self, selector: #selector(SwitchColors(notification:)), name: NSNotification.Name(rawValue: "HomeHeaderViewChange"), object: nil)
        self.navigationController?.setNavigationBarHidden(true, animated: true)
        setTableForDebitCard()
    }
    
    func setUpRefreshControl(){
        refreshControl.addTarget(self, action: #selector(self.refresh(_:)), for: .valueChanged)
        BasaMainHubTableView.addSubview(refreshControl)
    }
    
    func loadDebitBalance(){
        GSVCLoader.show()
        presenter?.requestBalance(Account: [accountNumber?.first?.key.encryptAlnova() ?? (GSSISessionInfo.sharedInstance.gsUser.account?.number?.encryptAlnova() ?? ""): accountNumber?.first?.value ?? (GSSISessionInfo.sharedInstance.gsUser.SICU?.encryptAlnova() ?? "")], Balance: { Balance in
            if let NewBalance = Balance{
                DispatchQueue.main.async {
                    self.accountBalance = NewBalance
                    UserDefaults.standard.setValue(NewBalance.resultado.cliente?.cuentas?.first?.clabe?.alnovaDecrypt().tnuoccaFormat, forKey: "DebitCardCLABE")
                    NotificationCenter.default.post(Notification(name: Notification.Name(rawValue: "reloadHeaderData"), object: NewBalance, userInfo: nil))
                    // self.loadDebitMovements()
                    self.loadDebitMovementsV2()
                }
            }else{
                self.BasaMainHubTableView.isHidden = false
                GSVCLoader.hide()
                self.presentBottomAlertFullData(status: .error, message: "No podemos cargar tu saldo en este momento, intenta más tarde", attributedString: nil, canBeClosed: true, animated: true, showOptionalButton: true, optionalButtonText:nil)
            }
            self.refreshControl.endRefreshing()
        })
    }
    
    func loadDebitMovementsV2(){
        var body = MovimientosBodyv2.init()
       
        body =  MovimientosBodyv2.init(transaccion: MovementsBodyDataV2.init(sicu: GSSISessionInfo.sharedInstance.gsUser.SICU, numeroCuenta:  GSSISessionInfo.sharedInstance.gsUser.account?.number?.formatToTnuocca14Digits().encryptAlnova(), geolocalizacion: Geolocalizacion.init(latitud: "", longitud: "")))
        
        self.presenter?.requestDebitCardMovementsV2(Body: body, Movements: { [self] Movements in
            GSVCLoader.hide()
            self.BasaMainHubTableView.isHidden = false
            if Movements != nil{
                debitCardMovementsV2 = Movements
                setTableForDebitCard()
                if myMoneyFrameworkSettings.shared.showCredit == true{
                    loadActiveCardV2()
                }
            }else{
                self.presentBottomAlertFullData(status: .error, message: "No podemos cargar tus movimientos en este momento, intenta más tarde", attributedString: nil, canBeClosed: true, animated: true, showOptionalButton: true, optionalButtonText:nil)
            }
        })
    }
    
    func loadLends(){
        GSVCLoader.show()
        presenter?.requestUserLends(Lends: { [self]Lends in
            GSVCLoader.hide()
            if let LendsData = Lends{
                lendsData = LendsData
                NotificationCenter.default.post(Notification(name: Notification.Name(rawValue: "reloadLendsData"), object: LendsData, userInfo: nil))
                setTableForLends()
            }else{
                GSVCLoader.hide()
                self.presentBottomAlertFullData(status: .error, message: "No podemos cargar tus prestamos en este momento, intenta más tarde", attributedString: nil, canBeClosed: true, animated: true, showOptionalButton: true, optionalButtonText:nil)
            }
            self.refreshControl.endRefreshing()
        })
    }
    
    func loadCreditCardInfo(){
        let numberCard =  creditCardInfo?.body?.resultado?.tarjetas?.first?.numero?.dynamicEncrypt()
        GSVCLoader.show()
        presenter?.requestCreditCardData(Body: CreditCardBody.init(transaccion: CreditCardTransaccion.init(numeroCuenta: "", numeroTarjeta: numberCard, numeroContrato: "")), CreditCardData: { [self] CreditCardData in
            if let CreditCard = CreditCardData{
                creditCardData = CreditCard
                NotificationCenter.default.post(Notification(name: Notification.Name(rawValue: "reloadCreditCardData"), object: CreditCard, userInfo: nil))
                loadCreditCardBalance()
              
            }else{
                GSVCLoader.hide()
                self.presentBottomAlertFullData(status: .error, message: "No podemos obtener los datos de la tarjeta en este momento, intenta más tarde", attributedString: nil, canBeClosed: true, animated: true, showOptionalButton: true, optionalButtonText:nil)
            }
            self.refreshControl.endRefreshing()
        })
    }
    
    func loadCreditCardBalance(){
        presenter?.requestCreditCardBalance(Body: CreditCardBalanceBody.init(transaccion: CreditCardBalanceTransaccion.init(numeroTarjeta: creditCardInfo?.body?.resultado?.tarjetas?.first?.numero?.dynamicEncrypt())), CreditCardBalance: { [self] CreditCardBalance in
            
            if let creditCardBalanceResponse = CreditCardBalance{
                creditCardBalance = creditCardBalanceResponse
                NotificationCenter.default.post(Notification(name: Notification.Name(rawValue: "reloadCreditCardBalance"), object: creditCardBalanceResponse, userInfo: nil))
                setTableForCreditCard()
                
                presenter?.requestCreditCardContract(CardNumber: creditCardData?.resultado?.tarjetas?.first?.numero ?? "", CreditCardContract: { CreditCardContract in
                    if CreditCardContract != nil{
                        loadCreditCardMovements(idSubproducto: CreditCardContract?.resultado?.numeroContrato ?? "")
                    }else{
                        GSVCLoader.hide()
                        self.presentBottomAlertFullData(status: .error, message: "No se pudo obtener su contrato en este momento", attributedString: nil, canBeClosed: true, animated: true, showOptionalButton: true, optionalButtonText:nil)
                    }
                })
            }else{
                GSVCLoader.hide()
                self.presentBottomAlertFullData(status: .error, message: "No podemos obtener los saldos de la tarjeta de crédito en este momento, intente más tarde", attributedString: nil, canBeClosed: true, animated: true, showOptionalButton: true, optionalButtonText:nil)
            }
        })
    }
    
    func loadCreditCardMovements(idSubproducto: String){
        let finalDate = Date().withFormatter(formatter: "yyyy-MM-dd")
        let initialDate = Calendar.current.date(byAdding: .day, value: -60, to: Date())?.withFormatter(formatter: "yyyy-MM-dd")
        
        presenter?.requestCreditCardMovements(Body: CreditCardMovementsBody.init(transaccion: CreditCardMovementsTransaccion.init(fechaFin: finalDate, idSubproducto: idSubproducto.removeWhiteSpaces(), fechaInicio: initialDate, numeroDias: "60")), CreditCardMovements: { [self] CreditCardMovements in
            GSVCLoader.hide()
            
            if let CreditCardMovements = CreditCardMovements{
                creditCardMovements = CreditCardMovements
                setTableForCreditCard()
            }else{
                GSVCLoader.hide()
                self.presentBottomAlertFullData(status: .error, message: "No podemos obtener tus movimientos en este momento, intenta más tarde", attributedString: nil, canBeClosed: true, animated: true, showOptionalButton: true, optionalButtonText:nil)
            }
        })
    }
    
    func loadActivateCard(){
        presenter?.requestCreditCardBalance(Body: CreditCardBalanceBody.init(transaccion: CreditCardBalanceTransaccion.init(numeroTarjeta: GSSISessionInfo.sharedInstance.gsUser.account?.card?.dynamicEncrypt())), CreditCardBalance: { [self] CreditCardBalance in
            if let creditCardBalanceResponse = CreditCardBalance{
                creditCardBalance = creditCardBalanceResponse
                NotificationCenter.default.post(name: Notification.Name("creditCardAvailable"), object: nil)
            }else{
                presenter?.requestUserLends(Lends: {LendsResponse in
                    if LendsResponse != nil{
                        NotificationCenter.default.post(name: Notification.Name("onlyLendsAvaliable"), object: nil)
                    }else{
                        GSVCLoader.hide()
                    }
                })
            }
        })
    }
    
    func loadActiveCardV2(){
        presenter?.requestCreditCardNumber(CardInfoResponse: { [self] CreditCardInfoResponse in
            if CreditCardInfoResponse?.body?.resultado?.tarjetas?.first?.numero?.isValidCreditCard() == true{
                creditCardInfo = CreditCardInfoResponse
                NotificationCenter.default.post(name: Notification.Name("creditCardAvailable"), object: nil)
            }else{
                presenter?.requestUserLends(Lends: { LendsResponse in
                    if LendsResponse != nil{
                        NotificationCenter.default.post(name: Notification.Name("onlyLendsAvaliable"), object: nil)
                    }else{
                        GSVCLoader.hide()
                    }
                })
            }
        })
    }
    
    func ConfigureCollectionView(){
        self.RegisterCells()
        self.BasaMainHubTableView.delegate = self
        self.BasaMainHubTableView.dataSource = self
    }
    
    func RegisterCells(){
        let bundle = Bundle(for: BASAMainHubCardsViewController.self)
        self.BasaMainHubTableView.register(UINib(nibName: "BASACardsHeaderTableViewCell", bundle: bundle), forCellReuseIdentifier: "BASACardsHeaderCell")
        self.BasaMainHubTableView.register(UINib(nibName: "BASAHomeHeaderViewComponent", bundle: bundle), forCellReuseIdentifier: "BASAHomeHeaderViewComponent")
        self.BasaMainHubTableView.register(UINib(nibName: "BASAMovementTableViewCell", bundle: bundle), forCellReuseIdentifier: "BASAMovementCell")
        self.BasaMainHubTableView.register(UINib(nibName: "BASAButtonsCell", bundle: bundle), forCellReuseIdentifier: "BASAButtonsCell")
        self.BasaMainHubTableView.register(UINib(nibName: "RequestCardCell", bundle: bundle), forCellReuseIdentifier: "RequestCardCell")
        self.BasaMainHubTableView.register(UINib(nibName: "SectionCell", bundle: bundle), forCellReuseIdentifier: "SectionCell")
        self.BasaMainHubTableView.register(UINib(nibName: "BASACreditCardInfoCell", bundle: bundle), forCellReuseIdentifier: "BASACreditCardInfoCell")
        self.BasaMainHubTableView.register(UINib(nibName: "BASALendInfoCell", bundle: bundle), forCellReuseIdentifier: "BASALendInfoCell")
        self.BasaMainHubTableView.register(UINib(nibName: "BASAMyCreditItem", bundle: bundle), forCellReuseIdentifier: "BASAMyCreditItem")
        self.BasaMainHubTableView.register(UINib(nibName: "GSNoMovementsCell", bundle: bundle), forCellReuseIdentifier: "GSNoMovementsCell")
        self.BasaMainHubTableView.register(UINib(nibName: "GSSAOfflineControlCell", bundle: bundle), forCellReuseIdentifier: "GSOfflineControlCell")
    }
    
    func setTableForDebitCard(){
        viewMode = 0
        createTag(eventName: "SA|MD|movimientosDebito|pageView")
        let header = BasaMainHubTableView.dequeueReusableCell(withIdentifier: "BASAHomeHeaderViewComponent") as! BASAHomeHeaderViewComponent
        header.cellViewController = self
        let accountData = accountBalance?.resultado.cliente?.cuentas
        
        header.debitCardlblBalance.textColor = .white
        header.debitCardlblCardNumber.text = accountData?.first?.numero?.alnovaDecrypt()
        
        header.data = accountBalance
        header.debitButton.backgroundColor = UIColor(red: 130/255, green: 0/255, blue: 255/255, alpha: 1.0)
        header.debitButton.setTitleColor(.white, for: .normal)
        if cellsArray.count == 0{
            cellsArray.append([header:headerSize])
        }else{
            removeAllExceptFirst()
        }
        
        let buttons = BasaMainHubTableView.dequeueReusableCell(withIdentifier: "BASAButtonsCell") as! BASAButtonsCell
        buttons.cellViewController = self
        buttons.accountBalance = self.accountBalance
        cellsArray.append([buttons:206.0])
        
        let separator = BasaMainHubTableView.dequeueReusableCell(withIdentifier: "SectionCell") as! SectionCell
        separator.lblTitle.text = "Movimientos"
        cellsArray.append([separator:60.0])
        
        
        if debitCardMovementsV2 != nil{
            if  debitCardMovementsV2?.resultado?.movimientos?.count ?? 0 > 0{
                var index = -1
                for item in debitCardMovementsV2!.resultado!.movimientos!{
                    index += 1
                    if  item.descripcion?.alnovaDecrypt() != ""{
                        let movementCell = BasaMainHubTableView.dequeueReusableCell(withIdentifier: "BASAMovementCell") as! BASAMovementTableViewCell
                        movementCell.setArrow(amount: item.importe?.alnovaDecrypt() ?? "")
                        movementCell.lblAmount.text = item.importe?.alnovaDecrypt().removeWhiteSpaces().moneyFormatWithoutSplit()
                        let status = item.descripcionOperacion?.components(separatedBy: "|")
                        let urlFotoStatus = item.urlFoto?.components(separatedBy: "|")
                        
                        if status?.count ?? 0 >= 2{
                            if status![1] == "r"{
                                movementCell.setArrow(amount: "-")
                                let amount = item.importe?.alnovaDecrypt().removeWhiteSpaces()
                                movementCell.lblAmount.text = String((Double(amount ?? "0.0") ?? 0.0) * -1.0).moneyFormatWithoutSplit()
                                movementCell.lblDate.text = (item.fecha?.dateFormatter(format: "yyyy-MM-dd", outputFormat: "dd MMM yyyy") ?? "") + " " + "MOV. PENDIENTE"
                            }else{
                                movementCell.lblDate.text = item.fecha?.dateFormatter(format: "yyyy-MM-dd", outputFormat: "dd MMM yyyy")
                            }
                        }else if urlFotoStatus?.count ?? 0 >= 2{
                            
                            if urlFotoStatus![1] == "r"{
                                movementCell.setArrow(amount: "-")
                                let amount = item.importe?.alnovaDecrypt().removeWhiteSpaces()
                                movementCell.lblAmount.text = String((Double(amount ?? "0.0") ?? 0.0) * -1.0).moneyFormatWithoutSplit()
                                movementCell.lblDate.text = (item.fecha?.dateFormatter(format: "yyyy-MM-dd", outputFormat: "dd MMM yyyy") ?? "") + " " + "MOV. PENDIENTE"
                            }else{
                                movementCell.lblDate.text = item.fecha?.dateFormatter(format: "yyyy-MM-dd", outputFormat: "dd MMM yyyy")
                            }
                        }else{
                            movementCell.lblDate.text = item.fecha?.dateFormatter(format: "yyyy-MM-dd", outputFormat: "dd MMM yyyy")
                        }
                        movementCell.separator.isHidden = false
                        movementCell.tag = index
                        movementCell.lblTitle.text = item.concepto?.alnovaDecrypt()
                        cellsArray.append([movementCell:88.0])
                    }
                }
            }else{
                let emptyMovements = BasaMainHubTableView.dequeueReusableCell(withIdentifier: "GSNoMovementsCell")!
                cellsArray.append([emptyMovements:321])
            }
        }else{
            let emptyMovements = BasaMainHubTableView.dequeueReusableCell(withIdentifier: "GSNoMovementsCell")!
            cellsArray.append([emptyMovements:321])
        }
        addTableComponents()
    }
    
    func setTableForCreditCard(){
        createTag(eventName: "SA|MD|movimientosCredito|pageView")
        createTag(eventName: .pageView, section: "mi_dinero", flow: "dashboard", screenName: "movimientos", origin: "credito")
        viewMode = 1
        removeAllExceptFirst()
        
        if creditCardData == nil{
            loadCreditCardInfo()
        }
        
        //let digitalCardCell = BasaMainHubTableView.dequeueReusableCell(withIdentifier: "RequestCardCell") as! RequestCardCell
        //digitalCardCell.lblTitle.text = "Tarjeta digital"
        //digitalCardCell.cellViewController = self
        //digitalCardCell.cellButton.addTarget(self, action: #selector(showAlert), for: .touchUpInside)
        //cellsArray.append([digitalCardCell:119.0])
        
        let infoCreditCell = BasaMainHubTableView.dequeueReusableCell(withIdentifier: "BASACreditCardInfoCell") as! BASACreditCardInfoCell
        
        if creditCardData != nil{
            infoCreditCell.lblCreditLimit.text = creditCardBalance?.resultado?.montoLimiteCredito?.moneyFormatWithoutSplit()
            infoCreditCell.lblMinimumPayment.text = creditCardBalance?.resultado?.montoPagoMinimo?.moneyFormatWithoutSplit()
            
            infoCreditCell.lblCutOffDate.text = creditCardBalance?.resultado?.fechaCorte?.dateFormatter(format: "yyyy-MM-dd", outputFormat: "dd MMMM").removeZeroInDate().lowercased()
            
            
            let date = "Próxima fecha de pago \(creditCardBalance?.resultado?.fechaPago?.dateFormatter(format: "yyyy-MM-dd", outputFormat: "dd").removeZeroInDate() ?? "Desconocida") de \(creditCardBalance?.resultado?.fechaPago?.dateFormatter(format: "yyyy-MM-dd", outputFormat: "MMMM") ?? "")".lowercased()
            
            infoCreditCell.lblNextPaymentDate.text = date
            infoCreditCell.lblPaymentToSettle.text = creditCardBalance?.resultado?.saldoDispuesto?.moneyFormatWithoutSplit()
            infoCreditCell.lblNotInterestPayment.text = creditCardBalance?.resultado?.pagoSinInteres?.moneyFormatWithoutSplit()
        }
        //TAMAÑO ANTERIOR 380.0
        cellsArray.append([infoCreditCell:330.0])
        
        let separator = BasaMainHubTableView.dequeueReusableCell(withIdentifier: "SectionCell") as! SectionCell
        separator.lblTitle.text = "Movimientos"
        cellsArray.append([separator:60.0])
        
        if creditCardMovements?.resultado?.movimientos != nil{
            for item in creditCardMovements!.resultado!.movimientos!{
                let movement = BasaMainHubTableView.dequeueReusableCell(withIdentifier: "BASAMovementCell") as! BASAMovementTableViewCell
                movement.lblTitle.text = item.concepto
                movement.lblAmount.text = item.monto?.moneyFormatWithoutSplit() ?? ""
                
                movement.lblDate.text = item.fechaHora?.components(separatedBy: " ").first?.dateFormatter(format: "yyyy-MM-dd", outputFormat: "dd MMM yyyy")
                
                movement.setArrow(idTipo: item.idTipo ?? "")
                movement.separator.isHidden = false
                cellsArray.append([movement:88.0])
            }
        }else{
            let emptyMovements = BasaMainHubTableView.dequeueReusableCell(withIdentifier: "GSNoMovementsCell")!
            cellsArray.append([emptyMovements:321])
        }
        
        addTableComponents()
    }
    
    func setTableForLends(){
        createTag(eventName: "SA|MD|movimientosPrestamos|pageView")
        createTag(eventName: .pageView, section: "mi_dinero", flow: "dashboard", screenName: "movimientos", origin: "prestamos")
        viewMode = 2
        removeAllExceptFirst()
        
        let infoCell = BasaMainHubTableView.dequeueReusableCell(withIdentifier: "BASALendInfoCell") as! BASALendInfoCell
        
        infoCell.btnInfo.addTarget(self, action: #selector(showToolTip), for: .touchUpInside)
        if lendsData == nil{
            loadLends()
        }else{
            infoCell.lblNextPayment.text = "\(lendsData?.resultado?.fechaProximoPago?.dateFormatter(format: "yyyy/MM/dd", outputFormat: "dd") ?? "") de \(lendsData?.resultado?.fechaProximoPago?.dateFormatter(format: "yyyy/MM/dd", outputFormat: "MMMM") ?? "")"
            infoCell.lblPaymentWithDiscount.text = lendsData?.resultado?.pagoPuntual?.moneyFormatWithoutSplit()
            infoCell.lblSuggestedPayment.text = String(lendsData?.resultado?.pagoSugerido ?? 0).moneyFormatWithoutSplit()
            infoCell.lblFixedPayment.text = lendsData?.resultado?.pagoNormal?.moneyFormatWithoutSplit()
            infoCell.lblPaymentDay.text = lendsData?.resultado?.fechaProximoPago?.dateFormatter(format: "yyyy/MM/dd", outputFormat: "EEEE")
            infoCell.lblDigitalPayment.text = lendsData?.resultado?.pagoPuntualDigital?.moneyFormatWithoutSplit()
        }
        
        cellsArray.append([infoCell:290.0])
        
        let separator = BasaMainHubTableView.dequeueReusableCell(withIdentifier: "SectionCell") as! SectionCell
        separator.lblTitle.text = "Mis créditos"
        cellsArray.append([separator:60.0])
        
        if lendsData?.resultado?.productos != nil{
            for item in lendsData!.resultado!.productos!{
                //if item.id != 0{
                    let creditItem = BasaMainHubTableView.dequeueReusableCell(withIdentifier: "BASAMyCreditItem") as! BASAMyCreditItem
                    creditItem.lblAmount.text = item.pagoLiquidar?.moneyFormatWithoutSplit()
                    creditItem.setTitle(id: item.id ?? -1)
                    cellsArray.append([creditItem:180.0])
               // }
            }
        }
        
        addTableComponents()
    }
    
    func setTableForOfflineWallet(){
        removeAllExceptFirst()
        let offlineControl = BasaMainHubTableView.dequeueReusableCell(withIdentifier: "GSOfflineControlCell") as! GSSAOfflineControlCell
        cellsArray.append([offlineControl:135])
        
        let emptyMovements = BasaMainHubTableView.dequeueReusableCell(withIdentifier: "GSNoMovementsCell") as! GSNoMovementsCell
        emptyMovements.imgView.image = UIImage(named: "walletInfo", in: Bundle.init(for: BASAMainHubCardsViewController.self), compatibleWith: nil)
        emptyMovements.lblTitle.isHidden = true
        emptyMovements.lblSubtitle.text = "Aquí podrás reservar dinero para hacer compras, envíos y pagos aunque no tengas conexión a internet."
        cellsArray.append([emptyMovements:321])
        
        addTableComponents()
    }
    
    func removeAllExceptFirst(){
        if cellsArray.count > 0{
            let count = cellsArray.count
            for _ in 1..<count{
                cellsArray.removeLast()
            }
            
            var cellsToRemove: [IndexPath] = []
            
            for n in 1..<BasaMainHubTableView.numberOfRows(inSection: 0){
                cellsToRemove.append([0,n])
            }
            
            BasaMainHubTableView.deleteRows(at: cellsToRemove, with: .right)
        }
    }
    
    func addTableComponents(){
        var cellsToAdd: [IndexPath] = []
        for n in 1..<cellsArray.count{
            cellsToAdd.append([0,n])
        }
        BasaMainHubTableView.insertRows(at: cellsToAdd, with: .left)
    }
    
    func optionalAction() {()}
    
    @objc func activityObserve(){
        activityTime.shared.startTime = Date()
        activityTime.shared.time = 300.0
    }
    
    @objc func updateHeaderSize(sender: Notification){
        if cellsArray.count > 0{
            let cell = (cellsArray[0].first?.key)!
            UIView.animate(withDuration: 0.5) { [self] in
                BasaMainHubTableView.beginUpdates()
                cellsArray[0].updateValue(380.0, forKey: cell)
                BasaMainHubTableView.endUpdates()
            }
            refreshControl.endRefreshing()
            setUpRefreshControl()
        }
    }
    
    @objc func SwitchColors(notification: Notification){
        if notification.object != nil{
            let colorType = notification.object as! cardType
            switch colorType {
            case .credit:
                setTableForCreditCard()
            case .debit:
                setTableForDebitCard()
            case .lending:
                setTableForLends()
            case .offlineWallet:
                setTableForOfflineWallet()
            }
        }
    }
    
    @objc func showToolTip(){
        GSVTTooltipRouter.createModule(target: self, title: "Pago sugerido", message: "Es el pago correspondiente a esta semana, más una semana adelantada.")
    }
    
    @objc func showAlert(){
        createTag(eventName: .UIInteraction, section: "mi_dinero", flow: "dashboard", screenName: "movimientos", type: "click", element: "tarjeta_digital", origin: "credito")
        presentBottomAlertFullData(status: .caution, message: "En este momento no cuentas con tarjeta digital", attributedString: .none, canBeClosed: true, animated: true, showOptionalButton: false, optionalButtonText: nil)
    }
    
    @objc func refresh(_ sender: AnyObject) {
        switch viewMode{
        case 0:
            loadDebitBalance()
        case 1:
            loadCreditCardInfo()
        case 2:
            loadLends()
        default:
           ()
        }
    }
}

extension BASAMainHubCardsViewController:UITableViewDelegate,UITableViewDataSource{
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return cellsArray.count
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        return cellsArray[indexPath.row].first!.key
    }
    
    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {
        return cellsArray[indexPath.row].first!.value
    }
    
    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        if BasaMainHubTableView.cellForRow(at: indexPath) is BASAMovementTableViewCell{
            if debitCardMovementsV2?.resultado?.movimientos?.count ?? 0 > 0 && viewMode == 0{
                let item = BasaMainHubTableView.cellForRow(at: indexPath) as! BASAMovementTableViewCell
                let data = debitCardMovementsV2?.resultado?.movimientos![item.tag]
                let view = GSSAMovementPreviewRouter.createModule(index: item.tag, item: data!, array: debitCardMovementsV2!)
                view.modalPresentationStyle = .overCurrentContext
                self.present(view, animated: true, completion: nil)
            }
        }
    }
    
    func tableView(_ tableView: UITableView, didEndDisplaying cell: UITableViewCell, forRowAt indexPath: IndexPath) {
        activityObserve()
    }
}

public struct activityTime {
    static var shared = activityTime()
    var time          : TimeInterval?
    var startTime     : Date?
    private init() { }
}
